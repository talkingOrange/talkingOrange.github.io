---
layout: post
title:  "[Java] 12일차 수업"
date:   2023-07-18
categories: Java
---
# KB IT's Your Life 4기 - Java 알고리즘 12일차
--- 

### swea1233

```
package s1233;

import java.util.*;
import java.io.*;

public class Solution {
    
    static class Node{
        int value; // 노드 값
        char opr; // 노드 연산자
        int left,right; // 자식 노드 번호
        
        // 생성자 오버라이딩 2개 (연산자 있는 경우 없는 경우)
        public Node(int value, char opr, int left, int right) {
            super();
            // value와 opr은 서로 베타적이다. 공존하지 못함!
            this.value = value;
            this.opr = opr;
            this.left = left;
            this.right = right;
        }
        public Node(int value) {
            super();
            this.value = value;
        }

    }
    
    static int N; // 노드 개수
    static Node[] nodes;
    

    private static int calc(Node node) {
        // 연산자 추출
        char opr = node.opr;        
        if(opr == '-') {
            return calc(nodes[node.left]) - calc(nodes[node.right]);
        }
        else if(opr == '+') {
            return calc(nodes[node.left]) + calc(nodes[node.right]);
            }
        else if(opr == '/') {
            return calc(nodes[node.left]) / calc(nodes[node.right]);
        }
        else if(opr == '*') {
            return calc(nodes[node.left]) * calc(nodes[node.right]);
        }
        else {
            return node.value;
        }
    }
    
    
    public static void main(String[] args) throws IOException {
        
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));        
        
        for(int i=1;i<=10;i++) {
            int ans=0;
            StringTokenizer st = new StringTokenizer(br.readLine());
            int N=Integer.parseInt(st.nextToken());
            nodes = new Node[N+1];
            for(int j=1;j<=N;j++) {
                // st에는 현재 [정점번호, 연산자, 왼쪽 자식 번호, 오른쪽 자식 번호] 혹은 [정점번호, 숫자]
                st = new StringTokenizer(br.readLine());
                // 입력 토큰 개수 판별
                // 연산자인 경우
                if(st.countTokens()==4) {
                    // 정점 번호는 제거하기
                    st.nextToken();
                    
                    char c = st.nextToken().charAt(0);
                    int left_v = Integer.parseInt(st.nextToken());
                    int right_v = Integer.parseInt(st.nextToken());
                    
                    nodes[j]= new Node(0,c,left_v,right_v);
                }
                // 값인 경우
                else {
                    // 정점 번호는 제거하기
                    st.nextToken();
                    String tk = st.nextToken();
                    if(Character.isDigit(tk.charAt(0))) {
                        nodes[j]= new Node(Integer.parseInt(tk));
                    }else {
                        nodes[j]= new Node(0,tk.charAt(0),0,0);
                    }
                }
            }
            //연산식체크
            ans = 1;
            for (int j = 1; j <= N; j++) {
                Node nd = nodes[j];
                if(nd.opr == '\u0000') {//숫자노드이면
                    if(nd.left != 0 || nd.right != 0) {
                        ans = 0;
                        break;
                    }
                }else {//연산자노드
                    if(nd.left == 0||nd.right == 0) {//
                        ans = 0;
                        break;
                    }
                }
            }
            System.out.println("#"+i+" "+ans);
        }
    }

}
```


### 그리디 알고리즘

- 동전 개수의 최솟값 구하기

```
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class 동전개수 {
	static int N; // 동전 수
	static int total; // 목표 금액
	static int[] array; // 동전의 종류
	static int count; // 사용할 동전의 최솟값

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());
		N = Integer.parseInt(st.nextToken());
		total = Integer.parseInt(st.nextToken());

		array = new int[N];
		for (int i = 0; i < N; i++) {
			st = new StringTokenizer(br.readLine());
			array[i] = Integer.parseInt(st.nextToken());

		}

		for (int i = N - 1; i >= 0; i--) {
			if (array[i] <= total) {
				count += total / array[i];
				total %= array[i];
			}
		}

		System.out.println(count);
	}
}

```
