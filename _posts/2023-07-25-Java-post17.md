---
layout: post
title:  "[Java] 17일차 수업"
date:   2023-07-25
categories: Java
---
# KB IT's Your Life 4기 - Java 알고리즘 17일차

--- 

### 형변환

```
package day_16;

public class Review01 {
	public static void main(String[] args) {
		int i = 100;
		long l = 200;
		float f= l;
		long l2 = (long)f;
//		boolean b = (boolean)i; // boolean 타입은 숫자가 아니다. 정수형과 실수형 사이에는 형 변환이 불가능하다.
//		String s = (String) i;  //String은 객체기 때문에 숫자와 형변환 불가.
		//큰타입 = 큰타입 - 작은타입;
//		int j = 1.0 + 2;  오류발생. double + int = double인데 int에 담을 수 없음.

	}
}
```

### 변수의 초기화

```
package day_16;

public class Review02 {
	static int j; // 멤버 변수, 필드 (static을 사용해야 main 내부에서 사용 가능)

	public static void main(String[] args) {
		int i; // 지역 변수
		//System.out.println(i); //오류발생. 지역 변수는 초기화 필요
		System.out.println(j); //필드의 경우, null, 0, false로 초기화된다.
	}
}

```

### 메서드 오버로딩 / 오버라이딩

- 이름 동일
- 오버로딩 : 매개변수 다름 
- 오버라이딩 : 매개변수 동일, 리턴타입 동일(자식타입), 상속관계

> 매개변수? 타입, 개수, 순서 (주의: 이름은 달라도 영향XXXX)

```
//오류발생 - 오버라이딩은 상속관계여야한다.
class A{
public void a(){}
public static void a(){}
}
```

```
//오류 발생. 이름은 같고, 매개변수가 같으면 오버라이딩 규칙 적용
//static void a() {}
//static int a() {}
	
```

```
//오류발생 - 이름은 상관없다. 오류 발생한다. 
public void a(int a, int b){}
public static void a(int b, int a){}

```

### 변수의 메모리 공간

```
package day_16;

public class Review03 {
	int i = 100;
	static int j = 200;
	
	public static void main(String[] args) {
//		System.out.println(i); //오류 발생. 공간상 접근 불가
		
		Review03 r = new Review03();
		System.out.println(r.i); //이렇게 불러와야 접근 가능
		
		System.out.println(j); //j는 static임으로 접근 가능
		// ==
		System.out.println(Review03.j); //j와 동일한 결과임
		
	}
}

```


### Final 클래스

- 상속 불가능한 클래스

 `System.out.println(Math.PI);`

 
### 추상클래스

- new 를 할 수 없어서 상속받은 자식클래스를 이용해서 만들어야한다.

```
abstract MyShape{
   int x, y;
      public abstract String draw();
}
```

- abstract 메소드를 하나라도 가지고 있다면, abstract 클래스로 정의해야함.

### String + String
- String concatenation는 String과 String을 더하면 새로운 String을 만들어 값을 담음.
- StringBuffer는 값을 바꾸기 전에 누가 쓰고 있으면 안 쓰고 없으면 씀. 속도는 100배 느려지지만, 여러 객체들이 동시에 달려들였을 때, 안정적이다.
- StringBuilder는 자신의 크기를 키움. 공용이 아니라, 혼자서 쓰는 화장실.

> 언제이용? toString()을 추가할 때.

```
@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		builder.append("MyShape [x=");
		builder.append(x);
		builder.append(", y=");
		builder.append(y);
		builder.append("]");
		return builder.toString();
	}
```

> builder.append("MyShape [x=").append("얍"); 가 가능함.

```
//Chained call 이라고함. 
	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		builder.append("MyShape [x=").append(x).append(", y=").append(y).append("]");
		return builder.toString();
	}
```
