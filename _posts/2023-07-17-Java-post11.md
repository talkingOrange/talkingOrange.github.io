---
layout: post
title:  "[Java] 11일차 수업"
date:   2023-07-17
categories: Java
---
# KB IT's Your Life 4기 - Java 알고리즘 11일차

--- 

### 트리

> 정렬할 때 쓰이는 idea (정렬순서)

![image](https://github.com/talkingOrange/talkingOrange.github.io/assets/88815795/6ac35462-a33b-49cd-9661-a3b49d45e1ae)

![image](https://github.com/talkingOrange/talkingOrange.github.io/assets/88815795/7175176d-e49c-4d3c-8442-8e4c89e5e56a)

![image](https://github.com/talkingOrange/talkingOrange.github.io/assets/88815795/651949c6-3930-4b9e-8d97-ea60970c4519)


### 이진트리

- 왼쪽 : 작은 값
- 오른쪽 : 큰 값

> 중위순회 - 오름차순 정렬값을 구할 수 있음.

- 노드 클래스를 통해 CRUD를 구현한다.

```
static class Node<K,V>{
   private K key; //키 값
   private V data; //데이터
   private Node<K,V> left; //왼쪽 포인터
   private Node<K,V> right; //오른쪽 포인터
}
```

- 비교 리뷰 : 비교 함수 || ArrayList 활용하기

```
package 비교리뷰;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class ComparableExam {
	static class Person implements Comparable<Person>{
		String name;
		int age;
		
		public Person(String name, int age) {
			super();
			this.name = name;
			this.age = age;
		}

		@Override
		public int compareTo(Person o) {
			//음수: this가 선순위
			//양수: this가 후순위
			//0: 동일 순위
			return this.age - o.age;
		}
		
		@Override
		public String toString() {
			return name;
		}
	}
	
	static class NameComparator implements Comparator<Person>{
		@Override
		public int compare(Person o1, Person o2) {
			return o1.name.compareTo(o2.name);
		}
	}
public static void main(String[] args) {
	Person p1 = new Person("홍", 30);
	Person p2 = new Person("김", 35);
	
	System.out.println(p1.compareTo(p2));
	ArrayList<Person> arr = new ArrayList<Person>();
	arr.add(p2);
	arr.add(p1);
	
	System.out.println(arr);
	
	Collections.sort(arr); //arrayList안에있는 것들을 정렬하기 위해서는 Collections의 sort를 이용하면 된다.
	
	System.out.println(arr);
	
	NameComparator nc = new NameComparator();
	Collections.sort(arr,nc);
	System.out.println(arr);
}
}

```

- 트리

```
//트리
public class TreeExam {
	static class Node<K, V> {
		private K key; //Generic타입은 사용시간에 타입을 지정할 것이라고 미루는 타입이다.
		private V value; 
		private Node<K,V> left;
		private Node<K,V> right; //기본 null값
		
		public Node(K key, V value, TreeExam.Node<K, V> left, TreeExam.Node<K, V> right) {//TreeExam.은 없어도 된다.
			super();
			this.key = key;
			this.value = value;
			this.left = left;
			this.right = right;
		}
		
		public Node(K key, V value) {//TreeExam.은 없어도 된다.
			this(key, value, null, null);
		}
		
		public K getKey() {
			return key;
		}
		
		public V getValue() {
			return value;
		}
		
		@Override
		public String toString() {
			return "K: " + key + ", V: " + value + ", LEFT: " + left + ", RIGHT: " + right;
		}
	}

	public static void main(String[] args) {
		Node<String,Integer> node = new Node<String, Integer>("홍", 90, null, null);
		Node<String,Integer> node2 = new Node<String, Integer>("홍", 90);
		
		System.out.println(node.toString());
		System.out.println(node2);
	}
}

```

```
//이진탐색트리
import java.util.Comparator;

public class BinTree<K, V> {
	static class Node<K, V> {
		private K key; // Generic타입은 사용시간에 타입을 지정할 것이라고 미루는 타입이다.
		private V value;
		private Node<K, V> left;
		private Node<K, V> right; // 기본 null값

		public Node(K key, V value, Node<K, V> left, Node<K, V> right) {// TreeExam.은 없어도 된다.
			super();
			this.key = key;
			this.value = value;
			this.left = left;
			this.right = right;
		}

		public Node(K key, V value) {// TreeExam.은 없어도 된다.
			this(key, value, null, null);
		}

		public K getKey() {
			return key;
		}

		public V getValue() {
			return value;
		}

		@Override
		public String toString() {
			return "K: " + key + ", V: " + value + ", LEFT: " + left + ", RIGHT: " + right;
		}
	}

	private Node<K, V> root;
	private Comparator<? super K> comparator;

	public static void main(String[] args) {
		BinTree<Integer, String> tr = new BinTree<Integer, String>();

		// 등록
		Node<Integer, String> nd = new Node<Integer, String>(1, "홍길동");
		tr.add(nd.getKey(), nd.getValue());
	}

	private void add(K key, V value) {

		if (root == null) {
			root = new Node<K, V>(key, value);
		} else {
			addNode(root, key, value);
		}
	}

	private void addNode(Node<K, V> node, K key, V value) {

		// node의 키 값보다 작으면 LEFT, 아니면 RIGHT 저장
		int cond = comp(key, node.getKey());
		if (cond == 0) // 동일키가 이미 등록
			return;
		if (cond < 0) { // 왼쪽에 저장
			if (node.left == null)
				node.left = new Node<K, V>(key, value);
			else {
				addNode(node, key, value);
			}

		} else { // 오른쪽에 저장

		}

	}

	private int comp(K key1, K key2) {
		return comparator == null ? (((Comparable<K>) key1).compareTo(key2)) : comparator.compare(key1, key2);
	}
}

```

### 완전 이진트리

- 시간 복잡도 : O(log n) 아주 빠름
