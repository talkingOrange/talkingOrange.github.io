---
layout: post
title:  "[Java] 4일차 수업"
date:   2023-07-06
categories: Java
---
# KB IT's Your Life 4기 - Java 4일차

--- 

### 객체배열

- 기본 타입의 배열: int[],...
- 클래스, 객체의 배열: 객체 배열

```
package day_04;

public class MyMemberExam {
	public static void main(String[] args) {
		// 회원정보 관리 - 등록, 검색, 수정, 삭제 (CRUD)
		// 회원: 이름, 나이
		// ctrl + . : 오류가 발생한 곳으로 커서를 이동해줌.
		MyMember m1 = new MyMember("홍길동", 23);

		System.out.println(m1.toString());
		// = System.out.println(m1); 내부적으로 객체의 주소값이 입력되면, toString매서드가 호출되도록 함.

		// MyMember와 MyMember[]는 완전히 다른 타입이다. int와 int[]도 다른 타입으로 봐야한다.
		// 만들어진 객체의 총 개수 : 4개 (new가 4개)
		MyMember[] mems = new MyMember[3];
		mems[0] = new MyMember("길동이", 33);
		mems[1] = new MyMember("길동김", 25);
		mems[2] = new MyMember("길동박", 35);
	}
}
```

> 메모리 관리

![image](https://github.com/talkingOrange/talkingOrange.github.io/assets/88815795/f3388d14-db52-493c-9f65-f8e4fb899845)


```
//다음에 저장할 저장 위치를 따로 지정 X 
		MyMember[] mems2 = new MyMember[300];
		int count = 0; //객체 저장 위치 = 저장 개수
		mems2[count++] = new MyMember("길동이", 33);
		mems2[count++] = new MyMember("길동김", 25);
		mems2[count++] = new MyMember("길동박", 35);
```

> CRUD

```
		//목록출력
		System.out.println("** 목록 **");
		for (int i = 0; i < count; i++) {
			System.out.println(mems[i]);
		}
		//회원검색
		System.out.println("** 회원검색 **");
		String findName = "길동이";
		int targetIndex = -1; //찾은 회원의 위치번호.
		for (int i = 0; i < count; i++) {
			if(findName == mems[i].getName()) {
				targetIndex = i;
			}
		}
		if(targetIndex == -1) {
			System.out.println("못찾았음");
		}else {
			System.out.println("찾았음: " + mems[targetIndex]);
		}
		
		//수정: 길동이의 나이를 1증가시킬 것.
		System.out.println("** 회원수정 **");
		for (int i = 0; i < count; i++) {
			if(findName == mems[i].getName()) {
				targetIndex = i;
			}
		}
		if(targetIndex == -1) {
			System.out.println("못찾았음");
		}else {
			System.out.println("찾았음: " + mems[targetIndex]);
			// 검색 코드에서 이 부분을 추가하면 수정 코드가 됨.
			int age = mems[targetIndex].getAge();
			mems[targetIndex].setAge(age+1);
			System.out.println("수정후: "+ mems[targetIndex]);
		}
		
		
		//삭제: 길동이를 찾아서 삭제할 것.
		System.out.println("** 회원삭제 **");
		for (int i = 0; i < count; i++) {
			if(findName == mems[i].getName()) {
				targetIndex = i;
			}
		}
		if(targetIndex == -1) {
			System.out.println("못찾았음");
		}else {
			System.out.println("찾았음: " + mems[targetIndex]);
			// 검색 코드에서 이 부분을 추가하면 삭제 코드가 됨.
			// 다음 index에 값을 덮어씌운다. 그리고 count값을 줄인다. 
			mems[targetIndex] = mems[targetIndex+1];
			count--;
			
		}
		
		//삭제후 목록 출력
		System.out.println("** 목록 **");
		for (int i = 0; i < count; i++) {
			System.out.println(mems[i]);
		}
		
```

### Manager/Service 클래스 작성

```
package day_04;

public class MyMemberExam2 {
	public static void main(String[] args) {
		MyMemberService ms = new MyMemberService();
		MyMember mm = new MyMember("홍길동", 33);
		ms.add(mm);
		mm = new MyMember("김길동", 30);
		ms.add(mm);
		mm = new MyMember("박길동", 23);
		ms.add(mm);
		System.out.println("저장 개수= " + ms.getCount());

		// 목록출력
		ms.printAll();

		// 검색 - 김길동의 참조값 반환 / 순서번호 반환 (문제 발생 가능성 높음)
		// 검색의 성공/실패 -> 성공:0 or 양수 (옛날 style), 실패: -1 / true false / 참조값 null (객체지향
		// style)
		MyMember findMem = ms.searchByName("김길동");
		if (findMem == null) {
			System.out.println("못 찾음");
		} else {
			System.out.println("찾음: " + findMem);
		}

		// 수정 - 김길동의 나이 1증가
		boolean b = ms.update("김길동", 1);

		if (b) {
			System.out.println("수정성공: " + findMem);
		} else {
			System.out.println("수정실패");
		}

	}
}

```

```
package day_04;

import java.util.Iterator;

public class MyMemberService {
	private MyMember[] mems = new MyMember[300];
	private int count = 0;

	public MyMemberService() {
	}

	public void add(MyMember mm) {
		mems[count] = mm;
		count++;
		// 한줄로 mems[count++] = mm; 해도 됨.
	}

	public int getCount() {
		return count;
	}

	public void printAll() {
		System.out.println("** 전체 출력 **");
		System.out.println("* 저장 개수 = " + count);
		for (int i = 0; i < count; i++) {
			System.out.println(mems[i]);
		} // end for

	}// end printAll()

	public MyMember searchByName(String findName) {
		for (int i = 0; i < count; i++) {
			if (findName == mems[i].getName()) {
				return mems[i];
			}
		} // end for
		return null; // 검색 실패
	}

	public boolean update(String name, int i) {
		MyMember m = searchByName(name);
		if(m == null) {
			return false;
		}
		
		int age = m.getAge();
		m.setAge(age+1);
		
		return true;
	}
}

```


### 상속, 추상, 인터페이스, 다형성

- 상속
자바는 다중 상속 지원X -> 하나의 부모 클래스만 상속

사용 가능한 class 정의 위치
```
package day_04;

public class ExtendsExam {
	public static void main(String[] args) {

		class A{}
	}
	class B{}
 }
class B{} //가장 일반적임.

```

```
package day_04;

public class ExtendsExam {
	public static void main(String[] args) {
		A a1 = new A();
		a1.i = 100;
		B b1 = new B();
		b1.i = 200;
		b1.j = 300;
		
		
	}
}
class A{int i;}
//다중상속 불가!!!!!!!!!!!!!!
class B extends A{int j;
public void prn() {
	this.i = 500;}
}

```

- 초기화가 부모 클래스부터 발생함. 그래서 자식에 부모 클래스 생성자를 불러오는 코드가 없으면 에러가 남.

- 오버라이딩
: 상속관계에서 상속 메서드를 자식 클래스에서 재정의하는 것. 호출시점에서 자식클래스 메서드가 우선 호출.
* 오버로딩은 리턴 타입이 달라도 되지만, 오버라이딩은 반드시 상속관계여야하고 파라미터가 모두 같아야한다. 즉, 함수 이름이 같을 때, 파라미터가 같냐 다르냐에 따라 오버로딩인지 라이딩인지 갈라진다.

- 부모가 퍼블릭이면 자식도 퍼블릭이어야한다. 더 큰 지정을 해주어야한다. 

```
package day_04;

public class SchoolExam {
	public static void main(String[] args) {
		// 학교 내 인원 관리
		// 관리 대상 - 학생, 교수, 직원
		// 학생 - 학번, 이름, 학과
		// 교수 - 교번, 이름, 연구실 호수
		// 직원(Employee) - 사번, 이름, 부서
		
		//class Person{ id, name}
		//class Student extends Person{ hakgwa }
		//class Teacher extends Person{ yeongusil }
		//class Emp extends Person{ buseo }

		Person p = new Person("100", "길동이");
		System.out.println(p);
		
		Student st = new Student("200", "김길동", "컴공");
		System.out.println(st);
		
		Emp e = new Emp("300", "박길동", "개발");
		System.out.println(e);
		
		Teacher t = new Teacher("400", "한길동", "302");
		System.out.println(t);
	}
}

```

```
package day_04;

public class Person {
	private String id, name;

	public Person() {
	}

	public Person(String id, String name) {
		super();
		this.id = id;
		this.name = name;
	}

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	@Override
	public String toString() {
		return "id=" + id + ", name=" + name ;
	}

}

```

```
package day_04;

public class Student extends Person{

	private String hakgwa;	
	
	public Student() {
		
	}

	public Student(String id, String name, String hakgwa) {
		setId(id);
		setName(name);
		// =super(id, name);
		this.hakgwa= hakgwa;
	}

	public String getHakgwa() {
		return hakgwa;
	}

	public void setHakgwa(String hakgwa) {
		this.hakgwa = hakgwa;
	}

	@Override
	public String toString() {
		return super.toString() + ", "+ "hakgwa=" + hakgwa ;
	}


}

```

```
package day_04;

public class Emp extends Person {
	
	private String buseo;
	
	public Emp() {
	}
	
	public Emp(String id, String name, String buseo) {
		super(id, name);
		this.buseo = buseo;
	}

	public String getBuseo() {
		return buseo;
	}

	public void setBuseo(String buseo) {
		this.buseo = buseo;
	}

	@Override
	public String toString() {
		return super.toString() + ", "+ "buseo=" + buseo  ;
	}


	
}

```

```
package day_04;

public class Teacher extends Person{
	
	private String yeongusil;
	
	public Teacher() {
	}
	
	public Teacher(String id, String name, String yeongusil) {
		super(id, name);
		this.yeongusil = yeongusil;
	}

	public String getYeongusil() {
		return yeongusil;
	}

	public void setYeongusil(String yeongusil) {
		this.yeongusil = yeongusil;
	}

	@Override
	public String toString() {
		return super.toString() + ", "+ "yeongusil=" + yeongusil;
	}
	
	

}

```


### 컬렉션 API(ArrayList, HashMap, TreeSet)
### Comparable, Comparator

